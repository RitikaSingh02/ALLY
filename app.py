from flask import Flask , render_template , make_response ,  redirect , request_started , request , jsonify , session
from flask.globals import session
from flask.helpers import url_for
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, login_user, logout_user, current_user, login_required ,UserMixin
from flask_migrate import Migrate

import os
import json
import bcrypt
from werkzeug.utils import secure_filename
from flask import send_from_directory
from dotenv import load_dotenv
load_dotenv('./.env')

app = Flask(__name__)
app.secret_key = os.environ.get("SECRET_KEY") or os.urandom(24)
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URI')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SESSION_TYPE'] = 'filesystem'
app.config['PERMANENT_SESSION_LIFETIME'] = 1800
app.config['UPLOAD_FOLDER'] = os.environ.get('UPLOAD_FOLDER')
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}

db = SQLAlchemy(app)
migrate = Migrate(app, db , compare_type=True , render_as_batch = True)
# Initialize login manager
login = LoginManager(app)
login.init_app(app)  # configuring the app for Flask-Login

@login.user_loader
def load_user(user_id):
    return User.query.get(user_id)
# It should return None (not raise an exception) if the ID is not valid.

#error handling
@app.errorhandler(404)
def not_found(e):
    # defining function
    return "unauthorized!" ,404
@app.errorhandler(405)
def not_found(e):
    # defining function
    return "method not allowed" , 405


############################################3#models#######################################3
class User(db.Model , UserMixin):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(25), nullable=False)
    gender = db.Column(db.String(25),  nullable=False)
    password = db.Column(db.String(256), nullable=False)
    is_admin = db.Column(db.Boolean, default=False, nullable=False)
    email = db.Column(db.String(120),unique = True ,nullable=False)
    is_verified = db.Column(db.Boolean, default=False, nullable=False)
    profile_pic = db.Column(db.String(200), nullable=True)


class UserRequestTypes(db.Model , UserMixin):
    __tablename__ = "requestcategory"
    id =db.Column(db.Integer, primary_key=True)
    request_type_name =  db.Column(db.String(200), nullable= False)
    
    
class UserRequest(db.Model , UserMixin):
    __tablename__ = "userrequests"
    id =db.Column(db.Integer, primary_key=True)
    request_type=db.Column(db.Integer, db.ForeignKey('requestcategory.id'))
    request_description  = db.Column(db.String(200), nullable=False)
    acc_holder_name = db.Column(db.String(200), nullable= True)
    phone = db.Column(db.String(200), nullable= True)
    ifsc = db.Column(db.String(200), nullable= True)
    acc_no = db.Column(db.String(200), nullable= True)
    upi_id = db.Column(db.String(200), nullable= True)
    gpay = db.Column(db.String(200), nullable= True)
    amazon_pay = db.Column(db.String(200), nullable= True)
    paytm = db.Column(db.String(200), nullable= True)
    phone_pay = db.Column(db.String(200), nullable= True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'))
   
class UserFcms(db.Model , UserMixin):
    __tablename__ = "fcms"
    id =db.Column(db.Integer, primary_key=True)
    fcm_token = db.Column(db.String(200),unique = True , nullable=False)
    device_id = db.Column(db.String(200),unique = True , nullable=False)
    email = db.Column(db.String(200), db.ForeignKey('users.email'))    
    status = db.Column(db.String(200), default = "INSERT")
#####################################################################
#cloudinary config
import cloudinary
import cloudinary.uploader
cloudinary.config( 
  cloud_name = os.environ.get("cloud_name"),
  api_key = os.environ.get("api_key"), 
  api_secret = os.environ.get('api_secret')
)

#Cors removing func
def _build_cors_prelight_response():
    response = make_response()
    response.headers.add("Access-Control-Allow-Origin", "*")
    response.headers.add('Access-Control-Allow-Headers', "*")
    response.headers.add('Access-Control-Allow-Methods', "*")
    return response


# def _corsify_actual_response(response):
#     response.headers.add("Access-Control-Allow-Origin", "*")
#     return response

#####################################################################################################################
##########################################################################################################
#############################################################################################################################################################
##########################################################################################################
##########################################################################################################
#Email OTP Section
email_dict= {}
import random
def otp_generater(email):
    otp = random.randint(1000, 9999)#genrate otp
    print("to be very " , otp)
    if email not in email_dict:
        email_dict[email] = []
    email_dict[email].append(otp)
    return otp

def check(email , otp):
    print(otp , email)
    if email in email_dict and email_dict[email].pop(0) == int(otp):
        print("yay! you are verified")
        return True
    return False

#routes
@app.route('/index', methods=['POST'])
def index():
    # print(request.method=='POST')
    if request.method == "OPTIONS":  # CORS preflight
        return _build_cors_prelight_response()
    else:
        if request.method == 'POST':
            print(request.get_json(force=True))
            data = request.get_json(force=True)
            name = data["name"]
            gender = data["gender"]
            password = data["password"]
            email = data["email"]
            session['admin'] = False
            res = {}
            user = User.query.filter_by(email = email).first()
            if user is not None and user.is_verified is False :
                #email has to be verified
                email_verification(email)
            if User.query.filter_by(email = email).first() is not None:
                #user exists
                res['msg'] = "the user already exists return  to the login page"
                res['exists'] = 1
                res['verified'] = User.query.filter_by(email = email).first().is_verified
                if email in ['ritika.1923cs1076@kiet.edu' , 'sameer.1923co1066@kiet.edu']:
                    session['admin'] = True
                res['admin'] = session['admin']
                return jsonify(res), 401
            else:
                #register the user and login it
                res['msg'] = "new user logged in "
                res['exists'] = 0
                hashed = bcrypt.hashpw(password.encode("utf-8"),bcrypt.gensalt())
                if email.split('@')[1]!= 'kiet.edu':
                    res['msg'] = "kindly enter kiet email!!"
                    return res , 404
                if email in ['ritika.1923cs1076@kiet.edu' , 'sammerahmad.1923cs1100@kiet.edu']:
                    user = User(name = name, password=hashed , email = email , gender = gender , is_admin = True )
                    db.session.add(user)
                    db.session.commit()
                    session['admin'] = True
                else:
                    user = User(name = name, password=hashed , email = email , gender = gender )
                    db.session.add(user)
                    db.session.commit()

                user = User.query.filter_by(email = email).first()
                #call the email generator api
                if not user.is_verified:
                    #email has to be verified
                    email_verification(email)
                    return jsonify("mail sent") , 200
            return jsonify("kindly verify your email"), 404
                    

        
@app.route('/login', methods=['POST'])
def login():
        # print(request)
    res = {}
    if request.method == "OPTIONS":  # CORS preflight
        return _build_cors_prelight_response()
    else:
        print(request.get_json(force=True))
        data = request.get_json(force=True)
        if 'email' not in data or 'password' not in data:
            res['msg'] = 'Bad Request'
            return jsonify(res), 400
        password = data["password"]
        email = data["email"]
        user = User.query.filter_by(email = email).first()
        hashed = bcrypt.checkpw(password.encode('utf8') ,user.password.encode('utf-8'))
        print(hashed)
        if hashed:
            #login the user
            login_user(user)
            res['msg'] = "login success"
            session['admin'] = user.is_admin
            return jsonify(res), 200
        else:
            res['msg'] = "Invalid credentials"
            return jsonify(res), 401

@app.route("/logout", methods=['GET'])
@login_required
def logout():
    # print(current_user.name)
    # Logout user
    logout_user()
    res = {
        'msg' : 'logout success'
    }
    return jsonify(res) , 200

@app.route("/passwordchange", methods=[ 'POST'])
@login_required
def change_password():
    #endpoint to change pass  
    res = {}
    if request.method == "OPTIONS":  # CORS preflight
        return _build_cors_prelight_response()
    else:
        print(request.get_json(force=True))
        data = request.get_json(force=True)      
        if 'email' not in data or 'current_pass' not in data or 'new_pass' not in data:
            res['msg'] = 'Bad Request'
            return jsonify(res), 400
        email = data['email']
        curr_pass = data['current_pass']
        new_pass = data['new_pass']
        hashed = bcrypt.checkpw(curr_pass.encode('utf8') ,current_user.password.encode('utf8'))
        
        if hashed:
            new_pass_hashed = bcrypt.hashpw(new_pass.encode("utf-8"),bcrypt.gensalt())
            query = User.query.filter_by(email = email).update(dict(password = new_pass_hashed))
            db.session.commit()
            res['msg'] = "change password successfull"
            return  jsonify(res), 200
        res['msg'] = "enter correct original pass"
        return  jsonify(res), 200

@app.route('/profile', methods=[ 'GET'])
@login_required
def profile():
        # print(request)
    res = {}
    if request.method == "OPTIONS":  # CORS preflight
        return _build_cors_prelight_response()
    else:
        if request.method == "GET":  # CORS preflight
            res['name'] = current_user.name
            res['gender'] = current_user.gender
            res['email'] = current_user.email
            res['profile_pic'] = current_user.profile_pic
            return res , 200
        
###################Sending mails##################3
from flask_mail import Mail, Message
app.config['MAIL_SERVER']='smtp.gmail.com'
app.config['MAIL_PORT'] = 465
app.config['MAIL_USERNAME'] = os.environ.get('EMAIL')
app.config['MAIL_PASSWORD'] = os.environ.get('PASSWORD')
app.config['MAIL_USE_TLS'] = False
app.config['MAIL_USE_SSL'] = True
mail = Mail(app)

def email_verification(email):   
    msg = Message('Kindly Verify Your Email To Proceed', sender = os.environ.get('MAIL'), recipients = [email])
    msg.body = "This is the email body"
    id = '1'
    msg.attach('mail.png','image/gif',open('./static/mail.png', 'rb').read(), 'inline', headers=[['Content-ID','<id>'],])
    #call the otp generator
    otp = otp_generater(email)
    msg.html = render_template('verify.html' , otp=otp , id = '<'+id+'>')
    mail.send(msg)
    
@app.route("/verify", methods = ['POST'])
def verify():
    data = request.get_json(force=True)      
    email = data['email']
    otp = data['otp']
    user = User.query.filter_by(email = email).first()
    res = {}
    res['msg'] = "not verified"
    res['verified'] = user.is_verified
    if (check(email , otp)):
            user.is_verified = True
            db.session.commit()
            res['msg'] = "verified"
            res['verified'] = user.is_verified
            return jsonify(res), 200
    return jsonify(res), 404
    
###################################333
###################################333
###################################333
##############request help section#############
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
@app.route('/uploads/<name>')
def download_file(name):
    return send_from_directory(app.config["UPLOAD_FOLDER"], name)

@login_required
@app.route('/upload' , methods = ['POST'])     
def upload_file():
    file = request.files['file']
    email = current_user.email
    if allowed_file(file.filename):
        filename = secure_filename(file.filename)
        upload_result = cloudinary.uploader.upload(file)
        user = User.query.filter_by(email = email).first()
        user.profile_pic = upload_result['url']
        db.session.commit()
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        return 'file uploaded successfully' , 200
    return "file upload failed"
        
@login_required
@app.route("/request_help", methods = ['POST'])
def request_help():
    if request.method == 'POST':
        print(request.files.getlist)
        data = request.get_json(force=True)  
        upi_id = data['upi_id']
        acc_no = data['acc_no']
        acc_holder_name = data['acc_holder_name']
        category_help = data['category_help']
        request_description = data['request_description']
        ifsc = data['ifsc']
        phone = data['phone']
        gpay = data['gpay']
        amazon_pay = data['amazon_pay']        
        paytm = data['paytm']        
        phone_pay = data['phone_pay']
        user = UserRequest(request_type = category_help , 
                           request_description = request_description , 
                           acc_holder_name = acc_holder_name,
                           phone = phone,
                           ifsc = ifsc,
                           acc_no = acc_no,
                           upi_id = upi_id,
                           gpay = gpay,
                           amazon_pay = amazon_pay,
                           paytm = paytm,
                           phone_pay = phone_pay,
                           user_id = current_user.id)
        db.session.add(user)
        db.session.commit()
        return jsonify("request sent successfully") , 200   
##############################3########33

##notifications section##
@login_required
@app.route('/fcm-insert' , methods = ['POST'])
def fcm_insert():
    res = {}
    data = request.get_json(force=True)  
    fcm_token = data['fcm_token']
    device_id = data['device_id']
    email = data['email']
    fcm = UserFcms(fcm_token = fcm_token , device_id = device_id , email = email , status = "INSERT")
    db.session.add(fcm)
    db.session.commit()
    res['msg'] = "fcm inserted"
    return jsonify(res), 200
    
@login_required
@app.route('/fcm-insert' , methods = ['POST'])
def fcm_del():
    res = {}
    data = request.get_json(force=True)
    fcm_token = data['fcm_token']
    device_id = data['device_id']
    fcm = UserFcms.query.filter_by(fcm_token = fcm_token , device_id = device_id).first()
    fcm.status = "DELETE"
    db.session.commit()
    res['msg'] = "fcm deleted successfully"
    return jsonify(res) , 200
    
@login_required
@app.route('/notifications' , methods = ['GET'])
def notification():
    data = request.get_json(force=True)  
    fcm_token = data['fcm_token']
    device = data['device']
    return render_template('notification.html') , 200
    
if __name__ == "__main__":
    db.create_all()
    app.run(debug=True, port=8080)

